---
title: Javascript Fundamentals Part 2
slug: javascript-fundamentals-part-2
excerpt: JavaScript is a high-level, dynamically typed, interpreted programming language that is used primarily for building interactive and responsive websites. JavaScript can be used to add dynamic behavior to a website, such as updating content on a page without having to reload the entire page, or to perform complex calculations and other operations in real-time.
imageUrl: https://images.unsplash.com/photo-1555099962-4199c345e5dd?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1770&q=80
author: Huy Nguyen, Software Engineer
day: 5
publishOn: 1677580045
---

## I. Strict Mode

**Strict Mode** is a feature in JavaScript that provides a restricted variant of JavaScript. When you use strict mode, it enables more warnings and disables certain behaviors that are prone to error or dangerous.

Using strict mode makes it easier to write **secure** JavaScript. Strict mode makes several changes to normal JavaScript semantics:

- Eliminates some JavaScript silent errors by changing them to throw errors.
- Prohibits the use of certain syntax that is potentially problematic and is not part of the ECMAScript specification.
- Disables features that are confusing or poorly understood.

Strict mode can be invoked in two ways:

- **On a per-function basis**: You can apply strict mode to a specific function by adding the "use strict" directive at the beginning of the function body.

```js
function strictFunction() {
  "use strict";
  // code goes here
}
```

- **On a per-file basis**: You can apply strict mode to an entire script file by adding the **"use strict"** directive at the top of the file.

```js
"use strict";
// code goes here
```

> In general, it's recommended to use strict mode in your code as it makes it easier to catch and prevent errors. However, be aware that some older code or libraries might not be compatible with strict mode, so you should test your code thoroughly before deploying it in strict mode.

## II. Functions

### 1. Function Declarations

**Function Declarations** are functions that are declared with the **function** keyword, followed by the **function name**, a list of **parameters** enclosed in parentheses, and the **function body**. The function body contains the statements that define what the function does. Function Declarations are **hoisted**, meaning they are moved to the top of their scope and can be called before they are defined in the code.

```js
function greet(name) {
  console.log("Hello, " + name + "!");
}

greet("John");
// Output: Hello, John!
```

### 2. Function Expressions

**Function Expressions** are similar to Function Declarations, but instead of using the **function** keyword, they are assigned to variables. Function Expressions are not hoisted and must be declared before they are called.

```js
let greet = function (name) {
  console.log("Hello, " + name + "!");
};

greet("Jane");
// Output: Hello, Jane!
```

### 3. Arrow Functions

**Arrow Functions** are a shorthand syntax for writing function expressions. They are declared with the **(=>)** operator and have a compact syntax that makes them useful for anonymous functions and small function expressions. Arrow functions do not have their own **this** value and automatically inherit the **this** value of the parent scope.

```js
let greet = (name) => {
  console.log("Hello, " + name + "!");
};

greet("John");
// Output: Hello, John!
```

> It's important to note that Arrow Functions should be used with caution in cases where the function body is complex, as they have a more limited syntax compared to traditional Function Declarations and Expressions.

## III. Arrays

### 1. Creating Arrays

You can create an array by using square brackets **[]** and separating elements with commas.

```js
var fruits = ["apple", "banana", "cherry"];
```

You can also create an array using the `Array` constructor:

```js
var fruits = new Array("apple", "banana", "cherry");
```

### 2. Accessing Array Elements

You can access an array element by using its **index** number. Array indexes start at **0**.

```js
var fruits = ["apple", "banana", "cherry"];

console.log(fruits[0]); // Output: apple
```

### 3. Modifying Array Elements

You can modify an array element by referring to its **index** number and assigning a new value to it.

```js
`var fruits = ["apple", "banana", "cherry"];

fruits[0] = "kiwi";
console.log(fruits[0]); // Output: kiwi;
```

### 4. Array Methods

JavaScript arrays have a number of built-in methods that allow you to manipulate the elements in an array. Some of the most commonly used methods are:

- **push()**: Adds an element to the end of an array.
- **pop()**: Removes the last element of an array.
- **shift()**: Removes the first element of an array.
- **unshift()**: Adds an element to the beginning of an array.
- **splice()**: Adds or removes elements from an array.
- **slice()**: Returns a new array that contains a portion of the original array.
- **concat()**: Joins two arrays and returns a new array.
- **join()**: Converts an array to a string and returns the result.
- **sort()**: Sorts the elements in an array.
- **reverse()**: Reverses the order of the elements in an array.

Here's an example that demonstrates some of these methods:

```js
const fruits = ["apple", "banana", "cherry"];

fruits.push("kiwi");
console.log(fruits); // Output: [ "apple", "banana", "cherry", "kiwi" ]

fruits.pop();
console.log(fruits); // Output: [ "apple", "banana", "cherry" ]

fruits.unshift("strawberry");
console.log(fruits); // Output: [ "strawberry", "apple", "banana", "cherry" ]

fruits.splice(1, 0, "orange");
console.log(fruits); // Output: [ "strawberry", "orange", "apple", "banana", "cherry" ]

const newFruits = fruits.slice(1, 3);
console.log(newFruits); // Output: [ "orange", "apple" ]

const combinedFruits = newFruits.concat(["mango"]);
console.log(combinedFruits); // Output: [ "orange", "apple", "mango" ]

const fruitString = fruits.join(", ");
console.log(fruitString);
```

## IV. Loops

### 1. for Loops

The **for** loop in JavaScript is a control flow statement that allows you to repeat a block of code a certain number of times. The basic syntax for a **for** loop is as follows:

```js
for (initialization; condition; increment / decrement) {
  // code to be executed
}
```

Here, **initialization** is where you initialize the loop counter; **condition** is the expression that is evaluated before each iteration of the loop; and **increment/decrement** is the statement that updates the loop counter after each iteration.

Here are some examples of using a **for** loop in JavaScript:

- Printing numbers from 1 to 10:

```js
for (let i = 1; i <= 10; i++) {
  console.log(i);
}
```

- Printing the elements of an array:

```js
const array = [1, 2, 3, 4, 5];

for (let i = 0; i < array.length; i++) {
  console.log(array[i]);
}
```

- Summing all the numbers in an array:

```js
const array = [1, 2, 3, 4, 5];
let sum = 0;

for (let i = 0; i < array.length; i++) {
  sum += array[i];
}

console.log(sum);
```

- Printing the properties of an object:

```js
const object = { a: 1, b: 2, c: 3 };

for (const property in object) {
  console.log(property + ": " + object[property]);
}
```

### 2. while Loops

The **while** loop in JavaScript repeatedly executes a block of code as long as a condition is true. It continues to loop until the condition becomes false. The syntax for a **while** loop is:

```js
while (condition) {
  // code to be executed
}
```

Here's an example that prints the numbers from 1 to 5:

```js
let i = 1;
while (i <= 5) {
  console.log(i);
  i++;
}

// Output:
// 1
// 2
// 3
// 4
// 5
```

> It's important to note that the condition must eventually become false, otherwise the loop will run indefinitely, leading to an infinite loop.

Here's an example of an infinite loop:

```js
while (true) {
  console.log("This is an infinite loop.");
}
```

> It's always a good practice to include a counter or some other mechanism to ensure that the condition eventually becomes false, to prevent infinite loops.

## V. Object

### 1. Object Literals

An **object literal** is a simple way of creating objects by defining properties and values directly within curly braces **(\{\})**.

```js
var person = {
  firstName: "John",
  lastName: "Doe",
  age: 30,
  fullName: function () {
    return this.firstName + " " + this.lastName;
  },
};
```

### 2. Object Constructors

An **object constructor** is a blueprint for creating objects, allowing you to create multiple objects with the same properties and methods.

```js
function Person(firstName, lastName, age) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
  this.fullName = function () {
    return this.firstName + " " + this.lastName;
  };
}

var person1 = new Person("John", "Doe", 30);
var person2 = new Person("Jane", "Doe", 28);
```

### 3. Prototypes

**Prototypes** allow you to add properties and methods to an object that can be inherited by all instances of that object.

```js
function Person(firstName, lastName, age) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
}

Person.prototype.fullName = function () {
  return this.firstName + " " + this.lastName;
};

var person1 = new Person("John", "Doe", 30);
var person2 = new Person("Jane", "Doe", 28);
```

### 4. Inheritance

**Inheritance** allows you to create a new object based on an existing object, inheriting its properties and methods.

```js
function Person(firstName, lastName, age) {
  this.firstName = firstName;
  this.lastName = lastName;
  this.age = age;
}

Person.prototype.fullName = function () {
  return this.firstName + " " + this.lastName;
};

function Student(firstName, lastName, age, school) {
  Person.call(this, firstName, lastName, age);
  this.school = school;
}

Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;

var student = new Student("John", "Doe", 30, "University of ABC");
```

## VI. ES6 Features

### 1. Arrow Functions

**Arrow functions** are a shorthand syntax for writing anonymous functions. They provide a more concise way of writing functions and automatically bind the **this** keyword to the context in which the function was defined.

```js

// ES5 function expression
var multiply = function(x, y) {
return x \* y;
};

// ES6 arrow function expression
const multiply = (x, y) => x \* y;
```

### 2. let and const

**let** and **const** are new ways of declaring variables in JavaScript. The key difference between **let** and **var** is that **let** has block-level scope, while **var** has function-level scope. **const** works similarly to **let**, but the value of a **const** variable cannot be reassigned after it's been declared.

```js
// Declare a variable with var
var name = "John Doe";
if (true) {
  var name = "Jane Doe";
  console.log(name); // Jane Doe
}
console.log(name); // Jane Doe

// Declare a variable with let
let age = 30;
if (true) {
  let age = 40;
  console.log(age); // 40
}
console.log(age); // 30

// Declare a constant with const
const PI = 3.14;
PI = 3.15; // TypeError: Assignment to constant variable.
```

### 3. Template Literals

**Template literals** are a way of embedding expressions within string literals, using backticks **(\`)**. They provide a more readable way of concatenating strings, especially when dealing with multi-line strings.

```js
// Concatenating strings with plus operator
var name = "John";
var message = "Hello, " + name + "!";

// Concatenating strings with template literals
const name = "John";
const message = `Hello, ${name}!`;
```

### 4. Destructuring

**Destructuring** is a convenient way of extracting values from **arrays** and **objects** into variables. This is especially useful when working with data structures that contain large amounts of data, and you only need to extract a small portion of it.

```js
// Extracting values from an array
const numbers = [1, 2, 3, 4, 5];
const [first, second, , fourth] = numbers;
console.log(first, second, fourth); // 1 2 4

// Extracting values from an object
const person = { name: "John", age: 30, occupation: "Developer" };
const { name, age } = person;
console.log(name, age); // John 30
```

### 5. Modules

**Modules** provide a way of organizing and sharing code between different files and modules. In ES6, the syntax for importing and exporting modules has been standardized, making it easier to split up code into smaller, more manageable chunks.

```js
// Exporting a module
export const name = "John";
export const age = 30;

// Importing a module
import { name, age } from "./person.js";
console.log(name, age); // John 30
```

### 6. Classes

**Classes** provide a way of creating objects using a blueprint-style syntax, similar to object-oriented programming languages. This makes it easier to create complex objects with similar structures and behavior, and makes the code more organized and easier to understand.

```js
// Defining a class
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(
      `Hello, my name is ${this.name} and I'm ${this.age} years old.`
    );
  }
}

// Creating an instance of the class
const person = new Person("John", 30);
person.sayHello(); // Hello, my name is John and I'm 30 years old.
```

### 7. Spread and Rest Operators

The **spread and rest operators** are used to spread the elements of an array into separate variables, or merge several arrays into one. The spread operator is denoted by three dots **(...)**, and the rest operator is denoted by the same, but within function parameters.

```js
// Spreading elements of an array into separate variables
const numbers = [1, 2, 3, 4, 5];
const [first, second, ...rest] = numbers;
console.log(first, second, rest); // 1 2 [3, 4, 5]

// Merging arrays into one with the spread operator
const firstArray = [1, 2, 3];
const secondArray = [4, 5, 6];
const combinedArray = [...firstArray, ...secondArray];
console.log(combinedArray); // [1, 2, 3, 4, 5, 6]

// Using the rest operator in function parameters
function sum(...numbers) {
  return numbers.reduce((a, b) => a + b, 0);
}
console.log(sum(1, 2, 3, 4, 5)); // 15
```

### 8. Default Parameters

**Default parameters** allow you to specify default values for function parameters, in case they're not provided when the function is called. This makes it easier to write functions that can handle missing or undefined arguments.

```js
// Function with default parameters
function greet(name = "John") {
  console.log(`Hello, ${name}!`);
}
greet(); // Hello, John!
greet("Jane"); // Hello, Jane!
```

### 9. Promises

**Promises** provide a way of handling asynchronous code and handling errors in a more elegant way. A promise represents a value that may not be available yet, but will be at some point in the future. Promises can be used to handle complex async flows, such as fetching data from an API, in a more manageable way.

```js
// Creating a promise
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Hello, World!");
  }, 1000);
});

// Using the promise
promise
  .then((message) => console.log(message))
  .catch((error) => console.error(error));
```

### 10. Generators

A generator function is a special type of function that allows you to define an iterator. You can pause the execution of a generator function at any point and resume it later, making it easier to implement asynchronous flows. The `yield` keyword is used to pause the generator function, and the `next()` method is used to resume it.

Here's a simple example of a generator function that generates the next value in the fibonacci sequence each time it's called:

```js
function fibonacci() {
    let [prev, curr] = [0, 1];
    while (true) {
    [prev, curr] = [curr, prev + curr];
    yield curr;
    }
}

const sequence = fibonacci();
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 1
console.log(sequence.next().value); // 2
console.log(sequence.next().value); // 3
console.log(sequence.next().value); // 5
```

### 11. Map, Set, and WeakMap/WeakSet:

- **Map**: is a collection of key-value pairs, where each key can be any value (including objects) and each value can be any data type. Maps offer better performance compared to traditional objects and are useful when you need to store data using non-string keys.

```js
const map = new Map();
map.set("name", "John");
map.set("age", 30);

console.log(map.get("name")); // "John"
console.log(map.get("age")); // 30
console.log(map.size); // 2
```

- **Set**: is a collection of unique values, where each value can be of any data type. Sets offer better performance compared to traditional arrays and are useful when you need to store a collection of unique values.

```js
const set = new Set();
set.add(1);
set.add(2);
set.add(3);
set.add(3);

console.log(set.has(1)); // true
console.log(set.has(4)); // false
console.log(set.size); // 3
```

- **WeakMap**: is a collection of key-value pairs, where the keys are weakly referenced. This means that if there are no other references to the key, the key-value pair will be automatically removed from the WeakMap. WeakMaps are useful when you need to store data that may not always be needed.

```js
const weakMap = new WeakMap();
const key = {};
weakMap.set(key, "value");
console.log(weakMap.get(key)); // "value"
key = null; // the key is no longer referenced
console.log(weakMap.get(key)); // undefined
```

- **WeakSet**: is a collection of weakly referenced values. This means that if there are no other references to the value, the value will be automatically removed from the WeakSet

```js
const weakSet = new WeakSet();
const value1 = {};
const value2 = {};
weakSet.add(value1);
weakSet.add(value2);

console.log(weakSet.has(value1)); // true
console.log(weakSet.has(value2)); // true
value1 = null; // the value is no longer referenced
console.log(weakSet.has(value1)); // false
```

### 12. Symbol:

A **Symbol** is a new data type in JavaScript that can be used to create unique object properties. Symbols are guaranteed to be unique, which makes them useful for defining private properties or for creating shared, hidden values.

```js
const name = Symbol("name");
const person = {
  [name]: "John",
};

console.log(person[name]); // "John"
```

## VII. JSON (JavaScript Object Notation)

### 1. What is JSON?

**JSON (JavaScript Object Notation)** is a lightweight data-interchange format that is easy for humans to read and write and easy for machines to parse and generate. It is based on a subset of the JavaScript programming language and is a text-based format, which means it uses human-readable text to transmit data objects consisting of attribute-value pairs. JSON is widely used for asynchronous browser/server communication and for data storage and data exchange formats in a variety of programming languages.

```json
{
  "name": "John Doe",
  "age": 35,
  "address": {
    "street": "123 Main St",
    "city": "Anytown",
    "state": "CA"
  },
  "phoneNumbers": [
    {
      "type": "home",
      "number": "555-555-1234"
    },
    {
      "type": "work",
      "number": "555-555-5678"
    }
  ]
}
```

### 2. Converting JSON Data

JSON data can be easily converted to JavaScript objects using the **JSON.parse()** method, and JavaScript objects can be converted to JSON data using the **JSON.stringify()** method.

```js
// Converting JSON data to a JavaScript object
const jsonData = '{"name": "John Doe", "age": 35}';
const obj = JSON.parse(jsonData);
console.log(obj.name); // Output: John Doe

// Converting a JavaScript object to JSON data
const person = { name: "Jane Doe", age: 30 };
const json = JSON.stringify(person);
console.log(json); // Output: {"name":"Jane Doe","age":30}
```

### 3.Working with API

**API (Application Programming Interface)** often returns data in **JSON** format, and JSON is often used to send data to API. When working with API, it is important to understand the structure of the JSON data being received, as well as how to make HTTP requests to retrieve the data.

```js
// Making a GET request to an API to retrieve data in JSON format
fetch("https://api.example.com/data")
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error(error));
```

In this example, the fetch function is used to make a **GET** request to the specified **API endpoint**. The response from the API is then passed to the **response.json()** method, which converts the response from a JSON string to a JavaScript object. The resulting object is then logged to the console.

## VIII. AJAX (Asynchronous JavaScript and XML)

### 1. What is AJAX?

**AJAX** stands for **Asynchronous JavaScript and XML**. It is a technique for creating fast and dynamic web pages by exchanging small amounts of data with the server, without reloading the entire page. AJAX allows web pages to update content dynamically, providing a more seamless and responsive user experience.

### 2. Sending HTTP Requests

The primary way that AJAX requests are sent is through the **XMLHttpRequest API** in JavaScript. This API allows you to make HTTP requests to a server, and receive the response, asynchronously. Here's an example of how to send a GET request using XMLHttpRequest:

```js
var xhr = new XMLHttpRequest();
xhr.open("GET", "https://example.com/data.json", true);
xhr.onreadystatechange = function () {
  if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();
```

In this example, we create a **new XMLHttpRequest** object and use the **open** method to specify the type of request **(GET)**, the URL ([https://example.com/data.json](https://example.com/data.json)), and whether the request should be asynchronous **(true)**. The **onreadystatechange** event handler is used to listen for changes in the request's status, and the **send** method is used to send the request.

### 3. Handling Responses

Once the server has responded to the request, the **onreadystatechange** event handler is executed, allowing you to handle the response. The **readyState** property of the XMLHttpRequest object indicates the current status of the request, and the **status** property indicates the HTTP status code returned by the server.

In the example above, we check if the **readyState** is **XMLHttpRequest.DONE** and the **status** is **200** **(OK)**, indicating that the request was successful. The response from the server is stored in the **responseText** property of the XMLHttpRequest object, and can be accessed and processed as needed.

Here's an example of how to parse a JSON response:

```js
var xhr = new XMLHttpRequest();
xhr.open("GET", "https://example.com/data.json", true);
xhr.onreadystatechange = function () {
  if (xhr.readyState === XMLHttpRequest.DONE && xhr.status === 200) {
    var data = JSON.parse(xhr.responseText);
    console.log(data);
  }
};
xhr.send();
```

In this example, we use the **JSON.parse** method to parse the JSON data returned by the server, and store the resulting JavaScript object in a variable **data**. The processed data can then be used to update the page dynamically.
